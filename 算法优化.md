若四阶段时间之和为$T=t_1+t_2+t_3+t_4$，每阶段计算时间为$t_{i,comp}$，通信时间为$t_{i, comm}$，且满足条件$t_i = \max\{t_{i, comp},t_{i, comm}\}$，其中$t_{i, comp}$由分组决定，为分组最大计算时间，$t_{i, comm}=\max\{D/B\}=\max\{D/(LB_l)\}$

$T\geq\sum t_{i, comp}$。若分组表示为$K_1$和$K_2$，满足以下条件：$K_1\subset\{1,2,...,N\}, K_2\subset\{1,2,...,N\}, K_1\cap K_2=\emptyset, K_1\cup K_2 = \{1,2,..,N\}$

各业务计算时间设为$c_j(j=1,2,...,N)$，$\max\{t_{i, comm}\}=\max\{c_j\}$。若业务使用PS架构，则$p_j=1$，反之$p_j=0$

若计算时间最大的业务索引为m，满足$c_m=\max\{c_j\}$

$p_m=0$:

说明计算时间最大的业务不是PS架构，此时$T\geq 2*c_m+t_a+t_b$，其中$t_a$和$t_b$是剩余的两个阶段计算时间，这两个阶段同属一组。

我们的思想是：逐步提高$t_a+t_b$，让T逼近最小值，

证明：计算时间固定的情况下，各阶段通信和计算间大气泡越小越好：

将问题换成图分割问题

确定：到底是两阶段拓扑尽量相同？还是按重构来，以提高各拓扑稀疏性，提高传输效率。

简化四阶段问题，回归二阶段，但 TE 过程稍微复杂，时间计算还要重新考虑。

链路考虑双向链路，与实际使用类似，tx/rx习惯配对使用，而mems开关的配置和方向无关。

将ps流量与其他业务流量分开，其余业务维护一个新流量矩阵，优先完成ps业务的一阶段，然后再传新流量矩阵和ps业务二阶段在该连接的流量------TE子优化问题

考虑两种方案，比较两种情况的结果：

1. 重构方案，这种方案下，完全无需考虑不重构，此时问题复杂度不高，可以通过缩小计算时间之和的方式迭代求解

2. 无重构方案，这种方案下，考虑两阶段同一拓扑，那就先根据总流量矩阵，然后确定单阶段拓扑，再将业务放进拓扑。

目的是减少单次迭代时间，具体方案是分两组，两阶段时间之和为$T=t_1+t_2$，一阶段分组为$K_1$，二阶段分组为$K_2$，满足：$K_1\cap K_2 = \emptyset$，$K_1\cup K_2=\{1,2,...,N\}$。每阶段计算时间为$t_{i,comp}$，通信时间为$t_{i, comm}$，且满足条件$t_i = \max\{t_{i, comp},t_{i, comm}\}$，$i\in\{0, 1\}$。各业务计算时间设为$c_j(j=1,2,...,N)，\max\{t_{i, comm}\}=\max\{c_j\}$。如果分两组，必有一组的计算时间为最大业务计算时间，不妨设最大业务索引为m，且第m个业务被分在了第0组，因此$T\geq c_m+t_2$。

此时下限为$c_m+t_2$。

我们的做法是，逐步增大$t_2$，并使得通信计算间气泡缩小。

两种算法：

不刻意考虑重构：此时默认各阶段都需要付出重构代价，重点在缩小气泡

按计算时间升序排列业务并遍历之，假设遍历到的业务索引为i，令$K_1=\{1, ..., i\}$。然后对这两组业务计算一个最短通信时间，找到这样一个索引i

找到第一个可以让计算时间完全覆盖通信时间的业务（同时满足两个条件：$t_{i,comm}\leq t_{i, comp}$，$2\times\varepsilon+t_{1,comm}+t_{2,comm}\leq t_{1,comp}+t_{2, comp}$）。然后找上一个业务，这个业务计算时间无法完全覆盖通信时间，然后我们优化上一个业务的分组。如果第一个业务就可以让计算时间完全覆盖通信时间，此时最优方案就是通信阶段和计算阶段完全分开。反之，如果最后一个业务都不能让计算时间完全覆盖通信时间，那就从最后一个业务优化起。

通信时间计算方式：ps可以通过参数分块等方法，将存在依赖的push和pull流水化，以使其不存在时间顺序，简化通信时间计算。

什么样的流量矩阵是传输友善的：稀疏化，由于放置固定，每个ToR上的流量也是固定的，因此流量矩阵越稀疏，对传输越友善。

分组时不考虑怎样稀疏化，用总流量算时间就行。

按计算时间升序排列业务并遍历之，然后以该业务为界分组，若遍历至第一个业务第二组计算时间就无法掩盖通信时间，就不重叠。繁殖，如果第二组可以掩盖，且第一组也能掩盖，那直接判断是否最小计算时间>所有业务传输总时间，如果成立，不重叠，否则分组为当前分组。如果第二组可以掩盖但第一组无法掩盖，开始遍历，遍历后会出现是否覆盖的状态变化，一开始为否是，会出现三种状态变化，分别为：是是，否否，是否。

如果第一次状态变化为是是的化，按照上述方法找到首个分组后，进一步组内优化，找通信时间露头端口的所有业务，

用总流量算一个总通信时间，然后总通信时间减掉最大计算时间，这个时间就是另一组刚好覆盖的计算时间。如果算出来的时间还小于0了，说明

最小计算时间>所有业务传输总时间或最小业务通信时间>最大计算时间，此时重叠反而会变差，但在这两个极端之间，合理重叠会降低时间。

刻意保证无重构：重点在无重构，

所谓通信时间叫无计算时间更贴切一些。

分组的本质是在简化调度复杂度的同时，让网络中的瓶颈空闲资源在每个时间都在做事

无重构情况，复杂度$O(n^2)$：

1. 先求总流量矩阵，并以此确定总拓扑，业务分为固定拓扑业务集合$f$和可变拓扑业务集合$uf$，设总流量矩阵为$D$，各业务流量矩阵为$D_i$；

2. 初始化总流量矩阵$D=\sum_{i\in f}D_i$；

3. 以总流量大小降序处理$uf$中的业务，通过优化该业务环拓扑的构成，以更好地匹配当前的流量矩阵，使之更稀疏化，并将获得的$D_i$加入$D$；

4. 通过$D$获得总拓扑$L$；

5. 按计算时间从小到大遍历各业务，然后以该业务为短组最长业务，那么可以初步确定一个分组，也就是，长组至少有比该业务计算时间长的所有业务，短组至少有该业务，然后对剩余业务进行组的分配；

6. 如果两组训练时间都小于现在的计算时间，或两组训练时间都长于现在的计算时间，那剩余的业务分组依据为业务与各组流量矩阵和拓扑的匹配度。按业务流量降序排列，判断匹配度，并确定分组，直到确定所有业务分组；

7. 如果一组训练时间高于计算时间，另一组低于，那么填入高于组即可。

8. 遍历完所有业务后，会得到$N-1$个结果，找到最低的即可。

有重构情况：

1. 按计算时间从小到大遍历各业务，然后以该业务为短组最长业务，那么可以初步确定一个分组，也就是，长组至少有比该业务计算时间长的所有业务，短组至少有该业务，然后对剩余业务进行组的分配；

2. 如果两组训练时间都小于现在的计算时间，或两组训练时间都长于现在的计算时间，那剩余的业务分组依据为业务与各组流量矩阵的匹配度。按业务流量降序排列，判断匹配度，并确定分组，直到确定所有业务分组；

3. 如果一组训练时间高于计算时间，另一组低于，那么填入高于组即可。

4. 遍历完所有业务后，会得到N-1个结果，找到最低的即可；

5. 根据分组计算拓扑。

Cassini设置：

网络：24台服务器，一台服务器一个A100（40GB HBM2内存， 50GB网卡），支持RDMA，网络为胖树架构，超额订阅比为2

业务：DNN模型，VGG11,VGG16,VGG19等，概率相同，迭代次数随机选择

并行化策略：数据并行业务（VGG，ResNet，BERT）采用分布式数据并行架构，使用Ring-AllReduce。DLRM，GPT使用数模混合并行，使用meta开源代码库训练DLRM，嵌入表分区，其余部分复制。使用DeepSpeed做GPT分区。

NCCL通信库可以通过搜索网络拓扑（商用集群，技术成熟，可以通过网络感知来确定最优业务通信模式，兼容多种训练---不适用于光，因为拓扑不确定，且非全局调度策略），来确定业务训练使用何种拓扑，FleXFlow搜索混合并行策略，Deepspeed可实现模型分区。DDR，BytePS是数据并行的两个经典框架，都兼容pytorch。类似NCCL的工作，但是目前只有两类业务，已知放置，业务可选择架构，一类固定拓扑，包括选择PS的业务和使用模型并行的业务，一类非固定拓扑，目前只考虑ring，后续暂不考虑。

技术栈：

1. 通信库：类似NCCL，功能算法设计相对简单，底层通信代码不变（拓扑）；

2. 调度器：Apache Hadoop YARN---控制业务调度（分组），GPU分配

系统上可实现。

先确定网络拓扑和分组，后NCCL? NCCL的抢占式调度不合理。

iteration内部无重构，重构发生在存在业务完成或出现新业务时。

总流程：

1. 初筛：找到所有无冲突业务，也就是这些业务独占，无需进入分组，直接分配连接并开始进行训练；（什么叫无冲突业务？业务独占这几个pod？无论业务拓扑怎么改，无论带宽分配怎么变，业务都可以独占pod的所有带宽；

2. 剩余业务对其进行二分组，放入集合$J$中，根据流量合并算法算一个数据矩阵，然后根据这一数据矩阵求解共用拓扑；

3. 按计算时间升序排列所有业务，然后将此业务作为短组最长业务，也就是说，比该业务计算时间长的业务都被放进了长组，剩下的业务需要分配给两个分组；

4. 此时无论怎样做剩下的分组，两组计算时间都不会改，根据分组和拓扑，求解通信时间，与对应计算时间比较。如果此时两个分组通信时间都长于计算时间，说明此时后续作业无论怎样分组都是不会做到时间被完全重叠的，此时找到业务流量匹配度最大业务和对应组别组进行逐个分组；如果一高一低，先填低组流量，具体方案是按低组业务匹配度从高到低加入分组，直到两组通信时长都长于计算；如果两组通信时间都低于计算时间，此时找到业务流量匹配度最大业务和对应组别进行逐个分组，直到变成一高一低。业务分组采用逐个分组方式，在一个业务确定分组后，需要重新计算其他业务的匹配度。做完所有分组后，完成这种情况下的分组，记录最后得到的各业务拓扑。

5. 若一组通信时间高于计算，一组低于，则通过修改共用拓扑来进行均衡，

6. 遍历所有业务后，将获得$N-1$个时间，找这些时间中的最低值，并以此方案确定业务的分组和拓扑。

7. （可加）引入多跳转发，进一步匹配两组流量矩阵和网络拓扑。

业务匹配度计算：

1. 已知网络拓扑，求最佳业务拓扑，先筛选出所有固定拓扑业务，获取流量矩阵，然后按数据量降序处理剩余拓扑可变业务；

2. 在处理每个业务时，需要确定业务此时使用的拓扑，找出这个业务相关的所有机架，根据网络拓扑和当前数据量，计算各条连接的完成时间；

3. 置空业务当前环拓扑，按完成时间升序排列所有连接，如果这条连接与业务当前环拓扑无交集，那么就将该连接收进环拓扑，否则观察下一条连接，直到业务拓扑成环；

4. 完成所有业务的拓扑求解后，获得此时的流量矩阵；

5. 根据1-4步骤，计算加入该业务后该组的通信时间$t_{add}$，加入前通信时间$t_{old}$和该业务单独使用该拓扑的时间$t_{id}$，业务匹配度为$\dfrac{t_{add}-t_{old}}{t_{id}}$，值越靠近1，说明匹配度越低，反之越靠近0，匹配度越高。

流量合并算法：

1. 按流量降序遍历所有端口（输入输出端口分开），为每个业务维护两个表，输入空闲节点表$IA$和输出空闲节点表$OA$，初始情况下，$IA=OA$；

2. 处理每个端口时，先找到所有拓扑已经固定的业务流量，包含两类，一类是本身拓扑就没有灵活性的业务，另一类是处理之前端口的时候已经确定了这个端口的连接。再根据端口类型和$IA$和$OA$两个表格，找到所有拓扑可变业务。对每个业务算一个连接权值，计算方案为连接数$\times$业务流量/总流量，按权值离最近整数的距离降序排列各拓扑可变业务。为端口建立一个一维权值数组，对应目前每个端口的已知总连接权值，初始化为拓扑固定业务流量对应的权值和；

3. 处理每个业务时，以输入端口为例，遍历业务输出空闲节点表中的各节点，找到最匹配的节点，即加入该业务后连接权值最靠近整数的节点。如果完全没有可连接的节点，找到自己输出空闲节点表中，在这些业务里共用频率最高的节点。更新该业务的$IA$和$OA$，并更新端口权值数组。重复上述操作知道完成所有拓扑可变业务的节点分配；

4. 处理完所有端口后，完成业务拓扑选择，可以据此求得流量矩阵。

先定拓扑还是先定分组？

先定分组的话，还要定业务拓扑和网络拓扑，

使用拉格朗日松弛方法求近似解。

这个问题可以建模成一个MILP模型，可以通过松弛，将其中的整数变量松弛成连续变量，并使用McCormick包络将模型变为LP模型，然后使用拉格朗日法求解，对结果做舍入（随机舍入？优化M次）。 

联合求解分组和拓扑：

1. 已知初始化的长组和短组，确定各组计算时间。

2. 为每个业务维护两个列表，分别为入端口需求$IA$和出端口需求$OA$。

3. 将各业务的入端口和出端口放进集合$P$中，并按流量降序排列，并遍历各端口，分别根据两个需求表找到两组的所有与该端口相关的业务，分别 算两组业务的理想通信时间，并于对应计算时间作比较。

4. 若两组计算时间都高于通信时间，计算该端口相对差距，即（计算时间-通信时间）/计算时间，分端口需要偏向相对差距小的业务；如果都低于通信时间，找到流量最大的分组，需要偏向该分组；反之如果一高一低，此时需要偏向计算时间比通信时间低的组。

5. 先找到该端口对应的所有拓扑已经固定的业务流量，包含两类，一类是本身拓扑就没有灵活性的业务，另一类是处理之前端口的时候已经确定了这个端口的连接。再根据端口类型和$IA$和$OA$两个表格，找到所有拓扑可变业务，对每个业务算一个连接权值，计算方案为连接数$\times$业务流量/总流量。对所有对应节点维护一个总连接权值，总连接权值为已确定业务的连接权值之和的小数点部分，目标是最小化各节点总连接权值之和。先为所有固定拓扑业务对应的所有连接提供一个端口，然后计算该分组下所有固定业务流量带来的连接权值，并更新所有节点的总连接权值。然后计算该分组的其他拓扑可变业务的连接权值，按照连接权值与最近整数的距离降序遍历这些业务，对这些业务，找到使得总连接权值最小的可连接节点，更新需求表，直到所有业务都完成该节点的拓扑选择。

6. 遍历完所有节点后，完成总拓扑的计算，并获得对应组各业务的拓扑； 

7. 对于另一个组，按照理想时间，求解各业务需要的带宽量，按带宽需求降序排列业务。通过剩余资源量来为业务确定拓扑，确定业务拓扑后，获得流量矩阵，可以求得时间。

8. 长短组算法遍历分组；

9. 使用联合优化算法获得总拓扑和业务拓扑，然后根据匹配度放业务；  

10. 找最优分组，已经对应的所有拓扑

联合优化策略：

1. 为每个端口初始化连接数组，数组长度为总端口数目，元素为端口间连接数目，并根据固定拓扑业务，为这些业务保证一条连接，并据此更新这些数组，并为这些端口确定最少足够使用连接数；

2. 按总流量降序处理端口，观察当前连接是否够业务使用，如果不可用，找 到最多不可用业务相关连接，和对应的另一个端口，判断增加一条连接再另一个端口会不会导致另一个端口无法服务其业务，如果不可以，找次高连接直到另一个端口也可以服务为止。建立连接，更新各端口连接数组，和各端口最少使用连接数； 

3. 如果可用，遍历所有端口，分别试着为其增加一条连接，先确定固定拓扑业务使用的连接，在各 组 组内根据流量大小降序，通过计算时间确定其他业务使用的连接，可以算得各端口得分。如果考虑计算时间后，时间没有降低，那么端口得分为0。选择可建立的  最高得分端口进行连接，直到无可连接端口为止，此时，将最终的业务连接使用固定化，并更新连接数组，和最少使用 连接数。  

将算法从遍历转为启发式，但是具体启发式，并将三个优化量解耦。     

分组-业务-网络：   

网络-分组-业务：   

业务-网络-分组：流量降序排列业务，按照最大流量共用确定 业务连接->获取总流量矩阵，求网络拓扑->求分组。

分组求解：按计算时间升序排 列所有业务，遍历所有切法，从最极端的最长业务单独分组开始，共有四种可能。

1. 短组和长组训练时间都更长->遍历下一种切法，直到短组通信时间更长。然后找到这一种切法和上一种切法的最小时间对应的切法；

2. 长组训练时间长，短组训练时间短->再怎s样该都无法解决，直接按照该方案进行分组；

3. 长组训练时间短，短组训练时间长->找到    下一种切法（四种情况，a. 短组和长组训练时间都更长；b. 长组和短组通信时间都更长；c. 长组训练时间长，短组训练时间短；d. 无下一种切法）。解决方案分别为：a：跳转至1；b：跳转至4；c：固定两组最长通信时间，根据网络拓扑适配度确定剩余业务分组；d：找到并应用最后一种切法；

4. 短组和长组训练时间都更短->找到下一种切法（两种情况，a. 短组训练时间短，长组训练时间长；b. 无下一种切法）。解决方法分别为：使用满足短组和长组训练时间更短的所有切法中，短组时间最长的切法，固定通信时间，根据拓扑适配度确定剩余业务分组。

确定业务成环方式：

1. 先找到所有固定拓扑业务，初始化总流量矩阵为这些业务的流量矩阵之和；

2. 对流量矩阵做填充，然后用匈牙利算法找到主成分，然后找到一个最大相关业务，确定其连接，更新流量矩阵；

3. 逐个确定连接，知道完成所有业务的成环方案。

TPE方案：

1. 根据得到的总流量矩阵，进行BVN分解；
2. 找到主成分置换矩阵，这些主成分应该满足节点互相可达，如果不满足，那么向后找置换矩阵，找到可以使得所有节点互相可达的置换矩阵加入主成分，然后根据主成分，找到所有不能被单跳转发的元素；
3. 将原流量矩阵与主成分组成的最优流量矩阵对比，按降序排列无法转发元素对应的业务流量，遍历节点，找到和最优矩阵差距最大的可转发节点，将这业务的该流量从该节点进行二跳转发；
4. 如果完全无法进行两跳转发，找最小跳数路径进行转发。
